"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.transformCall = exports.transformImport = void 0;
var resolve_1 = __importDefault(require("./resolve"));
var defaultTransformedFunctions = [
    'require',
    'require.resolve',
    'System.import',
    'import',
    // Jest methods
    'jest.genMockFromModule',
    'jest.mock',
    'jest.unmock',
    'jest.doMock',
    'jest.dontMock',
    'jest.setMock',
    'jest.requireActual',
    'jest.requireMock',
    // Older Jest methods
    'require.requireActual',
    'require.requireMock',
];
function transformImport(nodePath, state) {
    var t = state.t;
    if (state.visitedNode.has(nodePath)) {
        return;
    }
    if (!t.isStringLiteral(nodePath.node.source)) {
        return;
    }
    state.visitedNode.add(nodePath);
    resolve_1["default"](nodePath.node.source, state);
}
exports.transformImport = transformImport;
function transformCall(nodePath, state) {
    var t = state.t;
    if (state.visitedNode.has(nodePath)) {
        return;
    }
    var callee = nodePath.get('callee');
    var isNormalCall = defaultTransformedFunctions.some(function (v) { return matchesPattern(t, callee, v); });
    if (!isNormalCall && !t.isImport(callee)) {
        return;
    }
    state.visitedNode.add(nodePath);
    resolve_1["default"](nodePath.node.arguments[0], state);
}
exports.transformCall = transformCall;
function matchesPattern(t, calleePath, pattern) {
    var node = calleePath.node;
    if (t.isMemberExpression(node)) {
        return calleePath.matchesPattern(pattern);
    }
    if (!t.isIdentifier(node) || pattern.includes('.')) {
        return false;
    }
    var name = pattern.split('.')[0];
    return node.name === name;
}
